# ---------------------------------------------------------------
# Release — Build and publish the extension wheel
# Triggered on version tag push (e.g. v0.1.0) on main only.
# Stamps setup.py + azext_metadata.json with the tag version.
# ---------------------------------------------------------------
name: Release

on:
  workflow_dispatch:
  push:
    tags:
      - "v*"
    branches: [main]

permissions:
  contents: write

jobs:
  build:
    name: Build wheel
    runs-on: ubuntu-latest
    # Extra guard: only run when the tag points at main
    if: github.ref_type == 'tag'
    outputs:
      version: ${{ steps.ver.outputs.version }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Verify version consistency
        run: |
          SETUP_VERSION=$(python -c "import re, pathlib; m=re.search(r'VERSION\s*=\s*\"(.+?)\"', pathlib.Path('setup.py').read_text()); print(m.group(1))")
          META_VERSION=$(python -c "import json, pathlib; print(json.loads(pathlib.Path('azext_prototype/azext_metadata.json').read_text())['version'])")
          if [ "$SETUP_VERSION" != "$META_VERSION" ]; then
            echo "::error::Version mismatch: setup.py has '$SETUP_VERSION' but azext_metadata.json has '$META_VERSION'. These must match."
            exit 1
          fi
          echo "Versions match: $SETUP_VERSION"

      - name: Extract version from tag
        id: ver
        run: |
          # Strip leading "v" from tag (v0.2.0 → 0.2.0)
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          echo "version=$TAG_VERSION" >> "$GITHUB_OUTPUT"
          echo "Release version: $TAG_VERSION"

      - name: Verify tag matches source version
        run: |
          TAG_VERSION="${{ steps.ver.outputs.version }}"
          # Strip semver pre-release suffix (-rc.1, -preview, etc.) for comparison
          # because setup.py carries the base version only.
          TAG_BASE="${TAG_VERSION%%-*}"
          SRC_VERSION=$(python -c "import re, pathlib; m=re.search(r'VERSION\s*=\s*\"(.+?)\"', pathlib.Path('setup.py').read_text()); print(m.group(1))")
          echo "Tag version:    $TAG_VERSION"
          echo "Tag base:       $TAG_BASE"
          echo "Source version: $SRC_VERSION"
          if [ "$TAG_BASE" != "$SRC_VERSION" ]; then
            echo "::error::Tag base version ($TAG_BASE) does not match source version ($SRC_VERSION). Update setup.py and azext_metadata.json before tagging."
            exit 1
          fi
          echo "Version check passed"

      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install "setuptools<70" wheel==0.30.0

      - name: Validate governance policies
        run: |
          pip install pyyaml
          python -m azext_prototype.governance.policies.validate --dir azext_prototype/governance/policies/ --strict

      - name: Validate workload templates against policies
        run: python -m azext_prototype.templates.validate --dir azext_prototype/templates/workloads/ --strict

      - name: Stamp version into metadata
        run: |
          TAG_VERSION="${{ steps.ver.outputs.version }}"
          TAG_NAME="${{ github.ref_name }}"
          python -c "
          import json, pathlib
          p = pathlib.Path('azext_prototype/azext_metadata.json')
          d = json.loads(p.read_text())
          d['version'] = '$TAG_VERSION'
          import re
          d['azext.isPreview'] = bool(re.search(r'(a|b|rc|alpha|beta|preview|dev)\d*', '$TAG_NAME'))
          p.write_text(json.dumps(d, indent=2) + '\n')
          "
          echo "Stamped version: $TAG_VERSION"
          echo "Preview: $(python -c "import re; print(bool(re.search(r'(a|b|rc|alpha|beta|preview|dev)\d*', '$TAG_NAME')))")"

      - name: Inject App Insights connection string and build wheel
        run: |
          WHEEL_SRC="azext_prototype/telemetry/__init__.py"
          if [ -n "$APPINSIGHTS_CONNECTION_STRING" ]; then
            sed -i "s|^_BUILTIN_CONNECTION_STRING = \"\".*|_BUILTIN_CONNECTION_STRING = \"$APPINSIGHTS_CONNECTION_STRING\"|" "$WHEEL_SRC"
            grep -qF "$APPINSIGHTS_CONNECTION_STRING" "$WHEEL_SRC" && echo "App Insights connection string injected" || { echo "::error::Failed to inject connection string"; exit 1; }
          else
            echo "::warning::APPINSIGHTS_CONNECTION_STRING secret not set — telemetry will be disabled in this build"
          fi
          python setup.py bdist_wheel --dist-dir dist/
        env:
          APPINSIGHTS_CONNECTION_STRING: ${{ secrets.APPINSIGHTS_CONNECTION_STRING }}

      - name: Verify wheel contents
        run: |
          pip install dist/*.whl
          python -c "import azext_prototype; print('Extension package OK')"

      - name: Upload wheel artifact
        uses: actions/upload-artifact@v4
        with:
          name: az-prototype
          path: dist/*.whl

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Download wheel artifact
        uses: actions/download-artifact@v4
        with:
          name: az-prototype
          path: dist/

      - name: Extract release notes from HISTORY.rst
        id: notes
        run: |
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          python3 -c "
          import re, sys

          version = '$TAG_VERSION'
          text = open('HISTORY.rst').read()

          # Match version header (e.g. '0.2.0-preview' or '0.2.0')
          # Each section starts with a version line followed by a +++ underline
          sections = re.split(r'\n(?=\d+\.\d+\.\d+\S*\n\+)', text)
          for section in sections:
              if section.lstrip().startswith(version):
                  # Strip the version header and underline, keep the body
                  lines = section.strip().splitlines()
                  # Skip version line and underline
                  body = '\n'.join(lines[2:]).strip()
                  print(body)
                  sys.exit(0)

          print(f'::warning::No HISTORY.rst section found for {version}')
          " > release_notes.md
          echo "has_notes=$([ -s release_notes.md ] && echo true || echo false)" >> "$GITHUB_OUTPUT"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*.whl
          body_path: ${{ steps.notes.outputs.has_notes == 'true' && 'release_notes.md' || '' }}
          generate_release_notes: ${{ steps.notes.outputs.has_notes != 'true' }}
          draft: false
          prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') || contains(github.ref, 'preview') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # -------------------------------------------------------------------
  # Publish to the official Azure CLI extension index
  # Requires EXTENSIONS_INDEX_PAT secret with repo scope on
  # Azure/azure-cli-extensions.
  # -------------------------------------------------------------------
  publish-index:
    name: Update extension index
    needs: [build, release]
    runs-on: ubuntu-latest
    if: "!contains(github.ref, 'alpha') && !contains(github.ref, 'beta')"

    steps:
      - name: Download wheel artifact
        uses: actions/download-artifact@v4
        with:
          name: az-prototype
          path: dist/

      - name: Compute wheel metadata
        id: meta
        run: |
          WHEEL=$(ls dist/*.whl)
          FILENAME=$(basename "$WHEEL")
          SHA256=$(sha256sum "$WHEEL" | cut -d ' ' -f1)

          echo "filename=$FILENAME" >> "$GITHUB_OUTPUT"
          echo "sha256=$SHA256" >> "$GITHUB_OUTPUT"
          echo "version=${{ needs.build.outputs.version }}" >> "$GITHUB_OUTPUT"
          echo "download_url=https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/$FILENAME" >> "$GITHUB_OUTPUT"

      - name: Clone azure-cli-extensions fork
        run: |
          # Ensure fork exists (no-op if already forked)
          gh repo fork Azure/azure-cli-extensions --clone=false || true

          # Clone the fork via gh (handles auth automatically)
          GH_USER=$(gh api user -q .login)
          echo "Fork owner: $GH_USER"
          gh repo clone "${GH_USER}/azure-cli-extensions" azure-cli-extensions -- --depth 1

          # Add upstream for PR targeting
          cd azure-cli-extensions
          git remote add upstream https://github.com/Azure/azure-cli-extensions.git || true
        env:
          GH_TOKEN: ${{ secrets.EXTENSIONS_INDEX_PAT }}

      - name: Extract metadata from wheel
        id: whl_meta
        run: |
          pip install wheel==0.30.0
          WHEEL=$(ls dist/*.whl)
          # Replicate the exact logic from Azure/azure-cli-extensions util.py get_ext_metadata()
          python3 -c "
          import json, os, re, sys, tempfile, zipfile

          WHEEL_INFO_RE = re.compile(
              r'^(?P<namever>(?P<name>.+?)(-(?P<ver>\d.+?))?)'
              r'((-(?P<build>\d.*?))?-(?P<pyver>.+?)-(?P<abi>.+?)-(?P<plat>.+?)'
              r'\.whl|\.dist-info)$',
              re.VERBOSE).match

          whl = sys.argv[1]
          ext_name = 'prototype'

          ext_dir = tempfile.mkdtemp()
          with zipfile.ZipFile(whl, 'r') as zf:
              zf.extractall(ext_dir)

          metadata = {}

          # Step 1: azext_metadata.json
          pos_mods = [n for n in os.listdir(ext_dir) if n.startswith('azext_') and os.path.isdir(os.path.join(ext_dir, n))]
          if pos_mods:
              p = os.path.join(ext_dir, pos_mods[0], 'azext_metadata.json')
              if os.path.isfile(p):
                  with open(p) as f:
                      metadata.update(json.load(f))

          # Step 2: dist-info/metadata.json (contains generator field)
          for d in os.listdir(ext_dir):
              if d.endswith('.dist-info'):
                  parsed = WHEEL_INFO_RE(d)
                  if parsed and parsed.groupdict().get('name') == ext_name.replace('-', '_'):
                      p = os.path.join(ext_dir, d, 'metadata.json')
                      if os.path.isfile(p):
                          with open(p) as f:
                              metadata.update(json.load(f))

          print(json.dumps(metadata, indent=2, sort_keys=True))
          " "$WHEEL" > /tmp/wheel_metadata.json
          cat /tmp/wheel_metadata.json

      - name: Update index.json and service_name.json
        working-directory: azure-cli-extensions
        run: |
          python3 -c "
          import json, pathlib

          index_path = pathlib.Path('src/index.json')
          index = json.loads(index_path.read_text())

          # Use the full merged metadata from the wheel (matches what test_index.py expects)
          metadata = json.loads(pathlib.Path('/tmp/wheel_metadata.json').read_text())

          entry = {
              'filename': '${{ steps.meta.outputs.filename }}',
              'sha256Digest': '${{ steps.meta.outputs.sha256 }}',
              'downloadUrl': '${{ steps.meta.outputs.download_url }}',
              'metadata': metadata
          }

          # Replace existing entry or append
          extensions = index.get('extensions', {})
          extensions['prototype'] = [entry]
          index['extensions'] = extensions

          index_path.write_text(json.dumps(index, indent=4, sort_keys=True) + '\n')

          # Add service name mapping for azdev linter/style checks
          sn_path = pathlib.Path('src/service_name.json')
          sn = json.loads(sn_path.read_text())
          # service_name.json is an array of {Command, AzureServiceName, URL} objects
          existing = [e for e in sn if e.get('Command') == 'az prototype']
          if not existing:
              sn.append({
                  'Command': 'az prototype',
                  'AzureServiceName': 'Azure Prototype',
                  'URL': ''
              })
              sn.sort(key=lambda e: e.get('Command', ''))
              sn_path.write_text(json.dumps(sn, indent=2) + '\n')
              print('Added prototype to service_name.json')
          else:
              print('prototype already in service_name.json')
          "

      - name: Create PR against Azure/azure-cli-extensions
        working-directory: azure-cli-extensions
        run: |
          gh auth setup-git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          VERSION="${{ steps.meta.outputs.version }}"
          BRANCH="prototype/v${VERSION}"
          git fetch origin "$BRANCH" 2>/dev/null && git checkout "$BRANCH" || git checkout -b "$BRANCH"
          git add src/index.json src/service_name.json
          git commit -m "Update prototype extension to ${VERSION}"
          git push --force origin "$BRANCH"

          PR_BODY="$(cat <<EOF
          ## Summary
          Automated index update for the \`az prototype\` extension.

          - **Version**: ${{ steps.meta.outputs.version }}
          - **SHA-256**: \`${{ steps.meta.outputs.sha256 }}\`
          - **Download**: ${{ steps.meta.outputs.download_url }}
          - **Source release**: https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }}
          EOF
          )"

          # Try to create PR; if one already exists, update it instead
          GH_USER=$(gh api user -q .login)
          CREATE_OUTPUT=$(gh pr create \
            --repo Azure/azure-cli-extensions \
            --head "${GH_USER}:${BRANCH}" \
            --title "Update \`prototype\` extension to ${VERSION}" \
            --body "$PR_BODY" 2>&1) && echo "Created PR: $CREATE_OUTPUT" || {
            EXISTING_PR=$(echo "$CREATE_OUTPUT" | grep -oP '/pull/\K\d+' || true)
            if [ -n "$EXISTING_PR" ]; then
              echo "Updating existing PR #${EXISTING_PR}"
              gh api -X PATCH "repos/Azure/azure-cli-extensions/pulls/${EXISTING_PR}" \
                -f title="Update \`prototype\` extension to ${VERSION}" \
                -f body="$PR_BODY" --silent
            else
              echo "::error::Failed to create PR: $CREATE_OUTPUT"
              exit 1
            fi
          }
        env:
          GH_TOKEN: ${{ secrets.EXTENSIONS_INDEX_PAT }}
