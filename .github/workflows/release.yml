# ---------------------------------------------------------------
# Release — Build and publish the extension wheel
# Triggered on version tag push (e.g. v0.1.0) on main only.
# Stamps setup.py + azext_metadata.json with the tag version.
# ---------------------------------------------------------------
name: Release

on:
  workflow_dispatch:
  push:
    tags:
      - "v*"
    branches: [main]

permissions:
  contents: write

jobs:
  build:
    name: Build wheel
    runs-on: ubuntu-latest
    # Extra guard: only run when the tag points at main
    if: github.ref_type == 'tag'

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Verify version consistency
        run: |
          SETUP_VERSION=$(python -c "import re, pathlib; m=re.search(r'VERSION\s*=\s*\"(.+?)\"', pathlib.Path('setup.py').read_text()); print(m.group(1))")
          META_VERSION=$(python -c "import json, pathlib; print(json.loads(pathlib.Path('azext_prototype/azext_metadata.json').read_text())['version'])")
          if [ "$SETUP_VERSION" != "$META_VERSION" ]; then
            echo "::error::Version mismatch: setup.py has '$SETUP_VERSION' but azext_metadata.json has '$META_VERSION'. These must match."
            exit 1
          fi
          echo "Versions match: $SETUP_VERSION"

      - name: Extract version from tag
        id: ver
        run: |
          # Strip leading "v" from tag (v0.2.0 → 0.2.0)
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          echo "version=$TAG_VERSION" >> "$GITHUB_OUTPUT"
          echo "Release version: $TAG_VERSION"

      - name: Verify tag matches source version
        run: |
          TAG_VERSION="${{ steps.ver.outputs.version }}"
          # Strip semver pre-release suffix (-rc.1, -preview, etc.) for comparison
          # because setup.py carries the base version only.
          TAG_BASE="${TAG_VERSION%%-*}"
          SRC_VERSION=$(python -c "import re, pathlib; m=re.search(r'VERSION\s*=\s*\"(.+?)\"', pathlib.Path('setup.py').read_text()); print(m.group(1))")
          echo "Tag version:    $TAG_VERSION"
          echo "Tag base:       $TAG_BASE"
          echo "Source version: $SRC_VERSION"
          if [ "$TAG_BASE" != "$SRC_VERSION" ]; then
            echo "::error::Tag base version ($TAG_BASE) does not match source version ($SRC_VERSION). Update setup.py and azext_metadata.json before tagging."
            exit 1
          fi
          echo "Version check passed"

      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install build wheel setuptools

      - name: Validate governance policies
        run: |
          pip install pyyaml
          python -m azext_prototype.governance.policies.validate --dir azext_prototype/governance/policies/ --strict

      - name: Validate workload templates against policies
        run: python -m azext_prototype.templates.validate --dir azext_prototype/templates/workloads/ --strict

      - name: Stamp version into metadata
        run: |
          TAG_VERSION="${{ steps.ver.outputs.version }}"
          TAG_NAME="${{ github.ref_name }}"
          python -c "
          import json, pathlib
          p = pathlib.Path('azext_prototype/azext_metadata.json')
          d = json.loads(p.read_text())
          d['version'] = '$TAG_VERSION'
          d['azext.isPreview'] = 'rc' in '$TAG_NAME' or 'preview' in '$TAG_NAME'
          p.write_text(json.dumps(d, indent=2) + '\n')
          "
          echo "Stamped version: $TAG_VERSION"
          echo "Preview: $(python -c "print('rc' in '$TAG_NAME' or 'preview' in '$TAG_NAME')")"

      - name: Inject App Insights connection string and build wheel
        run: |
          WHEEL_SRC="azext_prototype/telemetry/__init__.py"
          if [ -n "$APPINSIGHTS_CONNECTION_STRING" ]; then
            sed -i "s|^_BUILTIN_CONNECTION_STRING = \"\".*|_BUILTIN_CONNECTION_STRING = \"$APPINSIGHTS_CONNECTION_STRING\"|" "$WHEEL_SRC"
            grep -qF "$APPINSIGHTS_CONNECTION_STRING" "$WHEEL_SRC" && echo "App Insights connection string injected" || { echo "::error::Failed to inject connection string"; exit 1; }
          else
            echo "::warning::APPINSIGHTS_CONNECTION_STRING secret not set — telemetry will be disabled in this build"
          fi
          python -m build --wheel --outdir dist/
        env:
          APPINSIGHTS_CONNECTION_STRING: ${{ secrets.APPINSIGHTS_CONNECTION_STRING }}

      - name: Verify wheel contents
        run: |
          pip install dist/*.whl
          python -c "import azext_prototype; print('Extension package OK')"

      - name: Rename wheel with tag version
        run: |
          TAG_VERSION="${{ steps.ver.outputs.version }}"
          BASE_VERSION=$(python -c "import re, pathlib; m=re.search(r'VERSION\s*=\s*\"(.+?)\"', pathlib.Path('setup.py').read_text()); print(m.group(1))")
          if [ "$TAG_VERSION" != "$BASE_VERSION" ]; then
            for f in dist/*.whl; do
              mv "$f" "${f/$BASE_VERSION/$TAG_VERSION}"
            done
          fi
          ls dist/

      - name: Upload wheel artifact
        uses: actions/upload-artifact@v4
        with:
          name: az-prototype
          path: dist/*.whl

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Download wheel artifact
        uses: actions/download-artifact@v4
        with:
          name: az-prototype
          path: dist/

      - name: Extract release notes from HISTORY.rst
        id: notes
        run: |
          TAG_VERSION="${GITHUB_REF_NAME#v}"
          python3 -c "
          import re, sys

          version = '$TAG_VERSION'
          text = open('HISTORY.rst').read()

          # Match version header (e.g. '0.2.0-preview' or '0.2.0')
          # Each section starts with a version line followed by a +++ underline
          sections = re.split(r'\n(?=\d+\.\d+\.\d+\S*\n\+)', text)
          for section in sections:
              if section.lstrip().startswith(version):
                  # Strip the version header and underline, keep the body
                  lines = section.strip().splitlines()
                  # Skip version line and underline
                  body = '\n'.join(lines[2:]).strip()
                  print(body)
                  sys.exit(0)

          print(f'::warning::No HISTORY.rst section found for {version}')
          " > release_notes.md
          echo "has_notes=$([ -s release_notes.md ] && echo true || echo false)" >> "$GITHUB_OUTPUT"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*.whl
          body_path: ${{ steps.notes.outputs.has_notes == 'true' && 'release_notes.md' || '' }}
          generate_release_notes: ${{ steps.notes.outputs.has_notes != 'true' }}
          draft: false
          prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') || contains(github.ref, 'preview') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # -------------------------------------------------------------------
  # Publish to the official Azure CLI extension index
  # Requires EXTENSIONS_INDEX_PAT secret with repo scope on
  # Azure/azure-cli-extensions.
  # -------------------------------------------------------------------
  publish-index:
    name: Update extension index
    needs: [build, release]
    runs-on: ubuntu-latest
    if: "!contains(github.ref, 'alpha') && !contains(github.ref, 'beta')"

    steps:
      - name: Download wheel artifact
        uses: actions/download-artifact@v4
        with:
          name: az-prototype
          path: dist/

      - name: Compute wheel metadata
        id: meta
        run: |
          WHEEL=$(ls dist/*.whl)
          FILENAME=$(basename "$WHEEL")
          SHA256=$(sha256sum "$WHEEL" | cut -d ' ' -f1)

          echo "filename=$FILENAME" >> "$GITHUB_OUTPUT"
          echo "sha256=$SHA256" >> "$GITHUB_OUTPUT"
          echo "version=${{ needs.build.outputs.version }}" >> "$GITHUB_OUTPUT"
          echo "download_url=https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/$FILENAME" >> "$GITHUB_OUTPUT"

      - name: Clone azure-cli-extensions fork
        run: |
          # Ensure fork exists (no-op if already forked)
          gh repo fork Azure/azure-cli-extensions --clone=false || true

          # Clone the fork via gh (handles auth automatically)
          GH_USER=$(gh api user -q .login)
          echo "Fork owner: $GH_USER"
          gh repo clone "${GH_USER}/azure-cli-extensions" azure-cli-extensions -- --depth 1

          # Add upstream for PR targeting
          cd azure-cli-extensions
          git remote add upstream https://github.com/Azure/azure-cli-extensions.git || true
        env:
          GH_TOKEN: ${{ secrets.EXTENSIONS_INDEX_PAT }}

      - name: Update index.json
        working-directory: azure-cli-extensions
        run: |
          python3 -c "
          import json, pathlib

          index_path = pathlib.Path('src/index.json')
          index = json.loads(index_path.read_text())

          entry = {
              'filename': '${{ steps.meta.outputs.filename }}',
              'sha256Digest': '${{ steps.meta.outputs.sha256 }}',
              'downloadUrl': '${{ steps.meta.outputs.download_url }}',
              'metadata': {
                  'azext.isPreview': True,
                  'azext.minCliCoreVersion': '2.50.0',
                  'azext.summary': 'Azure CLI extension for building rapid prototypes.',
                  'classifiers': ['Development Status :: 3 - Alpha'],
                  'name': 'prototype',
                  'version': '${{ steps.meta.outputs.version }}'
              }
          }

          # Replace existing entry or append
          extensions = index.get('extensions', {})
          extensions['prototype'] = [entry]
          index['extensions'] = extensions

          index_path.write_text(json.dumps(index, indent=4, sort_keys=True) + '\n')
          "

      - name: Create PR against Azure/azure-cli-extensions
        working-directory: azure-cli-extensions
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          VERSION="${{ steps.meta.outputs.version }}"
          BRANCH="prototype/v${VERSION}"
          git checkout -b "$BRANCH"
          git add src/index.json
          git commit -m "Update prototype extension to ${VERSION}"
          git push --force origin "$BRANCH"

          PR_BODY="$(cat <<EOF
          ## Summary
          Automated index update for the \`az prototype\` extension.

          - **Version**: ${{ steps.meta.outputs.version }}
          - **SHA-256**: \`${{ steps.meta.outputs.sha256 }}\`
          - **Download**: ${{ steps.meta.outputs.download_url }}
          - **Source release**: https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }}
          EOF
          )"

          # Check if a PR already exists for this branch
          GH_USER=$(gh api user -q .login)
          EXISTING_PR=$(gh pr list --repo Azure/azure-cli-extensions --head "${GH_USER}:${BRANCH}" --json number --jq '.[0].number // empty')
          if [ -n "$EXISTING_PR" ]; then
            echo "Updating existing PR #${EXISTING_PR}"
            gh pr edit "$EXISTING_PR" \
              --repo Azure/azure-cli-extensions \
              --title "Update \`prototype\` extension to ${VERSION}" \
              --body "$PR_BODY"
          else
            echo "Creating new PR"
            gh pr create \
              --repo Azure/azure-cli-extensions \
              --title "Update \`prototype\` extension to ${VERSION}" \
              --body "$PR_BODY"
          fi
        env:
          GH_TOKEN: ${{ secrets.EXTENSIONS_INDEX_PAT }}
