# Deployment Script Patterns

Standard patterns for deployment scripts (`deploy.sh`) used by both Terraform and Bicep agents. These scripts are generated during the build stage and executed during the deploy stage.

## Staged Deployment Pattern

Deployments follow a fixed stage ordering based on dependency layers:

| Order | Stage | Contents | Depends On |
|-------|-------|----------|------------|
| 1 | **foundation** | Resource group, networking (VNet, subnets, NSGs), managed identity, Key Vault | -- |
| 2 | **data** | Storage accounts, Cosmos DB, SQL databases, Redis Cache | foundation |
| 3 | **messaging** | Service Bus, Event Hub, Event Grid | foundation |
| 4 | **compute** | App Service, Container Apps, Functions, AKS | foundation, data |
| 5 | **ai** | Azure OpenAI, Cognitive Services, AI Search | foundation, data |
| 6 | **apps** | Application code deployment, configuration | compute, data |
| 7 | **docs** | Output capture, documentation generation | all |

Not all stages are required. The build stage determines which stages are needed based on the architecture. Empty stages are skipped automatically.

## Complete Script Template

```bash
#!/usr/bin/env bash
#
# deploy.sh -- Staged infrastructure deployment
# Generated by az prototype build
#
# Usage:
#   ./deploy.sh                    # Deploy all stages
#   ./deploy.sh --dry-run          # Plan/what-if only
#   ./deploy.sh --stage compute    # Deploy single stage
#   ./deploy.sh --from data        # Resume from a stage
#   ./deploy.sh --destroy          # Tear down all resources
#

set -euo pipefail

# ---------------------------------------------------------------------------
# Color output
# ---------------------------------------------------------------------------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

log_info()    { echo -e "${BLUE}[INFO]${NC}  $*"; }
log_success() { echo -e "${GREEN}[OK]${NC}    $*"; }
log_warn()    { echo -e "${YELLOW}[WARN]${NC}  $*"; }
log_error()   { echo -e "${RED}[ERROR]${NC} $*"; }
log_stage()   { echo -e "\n${CYAN}========================================${NC}"; \
                echo -e "${CYAN}  Stage: $*${NC}"; \
                echo -e "${CYAN}========================================${NC}\n"; }

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_NAME="${PROJECT_NAME:-}"
ENVIRONMENT="${ENVIRONMENT:-dev}"
LOCATION="${LOCATION:-eastus}"
DRY_RUN="${DRY_RUN:-false}"
DESTROY="${DESTROY:-false}"
TARGET_STAGE=""
FROM_STAGE=""
IAC_TOOL=""  # "terraform" or "bicep" -- set by build stage

# Stage ordering (fixed)
STAGES=("foundation" "data" "messaging" "compute" "ai" "apps" "docs")

# Track results
DEPLOYED_STAGES=()
FAILED_STAGE=""
START_TIME=$(date +%s)

# ---------------------------------------------------------------------------
# Parse arguments
# ---------------------------------------------------------------------------
while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run)    DRY_RUN=true; shift ;;
    --destroy)    DESTROY=true; shift ;;
    --stage)      TARGET_STAGE="$2"; shift 2 ;;
    --from)       FROM_STAGE="$2"; shift 2 ;;
    --env)        ENVIRONMENT="$2"; shift 2 ;;
    --location)   LOCATION="$2"; shift 2 ;;
    -h|--help)    usage; exit 0 ;;
    *)            log_error "Unknown option: $1"; exit 1 ;;
  esac
done

usage() {
  echo "Usage: ./deploy.sh [OPTIONS]"
  echo ""
  echo "Options:"
  echo "  --dry-run          Plan/what-if only, do not apply changes"
  echo "  --destroy          Tear down all deployed resources"
  echo "  --stage <name>     Deploy only the named stage"
  echo "  --from <name>      Resume deployment from the named stage"
  echo "  --env <name>       Environment name (default: dev)"
  echo "  --location <loc>   Azure region (default: eastus)"
  echo "  -h, --help         Show this help message"
}

# ---------------------------------------------------------------------------
# Load variables
# ---------------------------------------------------------------------------
load_variables() {
  local vars_file="$SCRIPT_DIR/environments/${ENVIRONMENT}.env"
  if [ -f "$vars_file" ]; then
    log_info "Loading variables from $vars_file"
    # shellcheck disable=SC1090
    source "$vars_file"
  fi

  # Terraform-specific: set tfvars path
  if [ "$IAC_TOOL" = "terraform" ]; then
    VARS_FILE="$SCRIPT_DIR/environments/${ENVIRONMENT}/terraform.tfvars"
  fi

  # Bicep-specific: set params file path
  if [ "$IAC_TOOL" = "bicep" ]; then
    PARAMS_FILE="$SCRIPT_DIR/environments/${ENVIRONMENT}.bicepparam"
  fi
}

# ---------------------------------------------------------------------------
# Prerequisite checks
# ---------------------------------------------------------------------------
check_prerequisites() {
  log_info "Checking prerequisites..."

  # Azure CLI
  if ! command -v az &>/dev/null; then
    log_error "Azure CLI (az) is not installed. Install from https://aka.ms/installazurecli"
    exit 1
  fi

  # Check login status
  if ! az account show &>/dev/null; then
    log_error "Not logged in to Azure. Run: az login"
    exit 1
  fi

  # Verify subscription
  local current_sub
  current_sub=$(az account show --query id -o tsv)
  log_info "Using subscription: $current_sub"

  # IaC tool check
  if [ "$IAC_TOOL" = "terraform" ]; then
    if ! command -v terraform &>/dev/null; then
      log_error "Terraform is not installed. Install from https://terraform.io/downloads"
      exit 1
    fi
    local tf_version
    tf_version=$(terraform version -json 2>/dev/null | python3 -c "import sys,json; print(json.load(sys.stdin)['terraform_version'])" 2>/dev/null || terraform version | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')
    log_info "Terraform version: $tf_version"
  fi

  if [ "$IAC_TOOL" = "bicep" ]; then
    # Bicep is included with Azure CLI, but verify it works
    if ! az bicep version &>/dev/null; then
      log_warn "Bicep CLI not found. Installing..."
      az bicep install
    fi
    local bicep_version
    bicep_version=$(az bicep version --query "bicepVersion" -o tsv 2>/dev/null || az bicep version 2>&1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')
    log_info "Bicep version: $bicep_version"
  fi

  log_success "All prerequisites met"
}

# ---------------------------------------------------------------------------
# Cleanup trap
# ---------------------------------------------------------------------------
cleanup() {
  local exit_code=$?
  local end_time
  end_time=$(date +%s)
  local duration=$(( end_time - START_TIME ))

  echo ""
  echo "==========================================="
  echo "  Deployment Summary"
  echo "==========================================="
  echo "  Duration:    ${duration}s"
  echo "  Mode:        $([ "$DRY_RUN" = "true" ] && echo "dry-run" || echo "apply")"
  echo "  Environment: $ENVIRONMENT"
  echo "  IaC Tool:    $IAC_TOOL"
  echo ""

  if [ ${#DEPLOYED_STAGES[@]} -gt 0 ]; then
    echo "  Completed stages:"
    for s in "${DEPLOYED_STAGES[@]}"; do
      echo "    - $s"
    done
  fi

  if [ -n "$FAILED_STAGE" ]; then
    echo ""
    log_error "Failed at stage: $FAILED_STAGE"
    echo "  Resume with: ./deploy.sh --from $FAILED_STAGE"
  fi

  if [ $exit_code -eq 0 ] && [ -z "$FAILED_STAGE" ]; then
    echo ""
    log_success "Deployment completed successfully"
  fi

  exit $exit_code
}

trap cleanup EXIT

# ---------------------------------------------------------------------------
# Stage execution -- Terraform
# ---------------------------------------------------------------------------
deploy_terraform_stage() {
  local stage_name="$1"
  local stage_dir="$SCRIPT_DIR/stages/${stage_name}"

  if [ ! -d "$stage_dir" ]; then
    log_warn "Stage directory not found: $stage_dir (skipping)"
    return 0
  fi

  cd "$stage_dir"

  # Initialize
  log_info "Initializing Terraform for stage: $stage_name"
  terraform init -input=false -no-color

  # Validate
  terraform validate -no-color

  if [ "$DRY_RUN" = "true" ]; then
    log_info "Planning (dry-run) stage: $stage_name"
    terraform plan -input=false -no-color \
      ${VARS_FILE:+-var-file="$VARS_FILE"}
  else
    log_info "Applying stage: $stage_name"
    terraform plan -input=false -no-color \
      ${VARS_FILE:+-var-file="$VARS_FILE"} \
      -out=tfplan
    terraform apply -input=false -no-color tfplan
    rm -f tfplan
  fi

  cd "$SCRIPT_DIR"
}

# ---------------------------------------------------------------------------
# Stage execution -- Terraform destroy
# ---------------------------------------------------------------------------
destroy_terraform_stage() {
  local stage_name="$1"
  local stage_dir="$SCRIPT_DIR/stages/${stage_name}"

  if [ ! -d "$stage_dir" ]; then
    return 0
  fi

  cd "$stage_dir"

  # Check if state exists
  if [ ! -f "terraform.tfstate" ] && [ ! -f ".terraform/terraform.tfstate" ]; then
    log_warn "No state found for stage: $stage_name (skipping)"
    cd "$SCRIPT_DIR"
    return 0
  fi

  terraform init -input=false -no-color

  if [ "$DRY_RUN" = "true" ]; then
    log_info "Planning destroy (dry-run) stage: $stage_name"
    terraform plan -destroy -input=false -no-color \
      ${VARS_FILE:+-var-file="$VARS_FILE"}
  else
    log_info "Destroying stage: $stage_name"
    terraform plan -destroy -input=false -no-color \
      ${VARS_FILE:+-var-file="$VARS_FILE"} \
      -out=tfplan-destroy
    terraform apply -input=false -no-color tfplan-destroy
    rm -f tfplan-destroy
  fi

  cd "$SCRIPT_DIR"
}

# ---------------------------------------------------------------------------
# Stage execution -- Bicep
# ---------------------------------------------------------------------------
deploy_bicep_stage() {
  local stage_name="$1"
  local template="$SCRIPT_DIR/stages/${stage_name}/main.bicep"

  if [ ! -f "$template" ]; then
    log_warn "Template not found: $template (skipping)"
    return 0
  fi

  local deploy_name="${PROJECT_NAME}-${stage_name}-$(date +%Y%m%d-%H%M%S)"

  # Validate syntax
  az bicep build --file "$template" --no-restore 2>/dev/null || true

  # Determine scope from the template
  local scope
  scope=$(head -5 "$template" | grep -o "targetScope.*=.*'[^']*'" | grep -oE "'[^']*'" | tr -d "'" || echo "resourceGroup")

  if [ "$scope" = "subscription" ]; then
    if [ "$DRY_RUN" = "true" ]; then
      log_info "What-if (dry-run) stage: $stage_name"
      az deployment sub what-if \
        --location "$LOCATION" \
        --template-file "$template" \
        ${PARAMS_FILE:+--parameters "$PARAMS_FILE"} \
        --name "$deploy_name"
    else
      log_info "Deploying stage: $stage_name (subscription scope)"
      az deployment sub create \
        --location "$LOCATION" \
        --template-file "$template" \
        ${PARAMS_FILE:+--parameters "$PARAMS_FILE"} \
        --name "$deploy_name"
    fi
  else
    local rg_name="rg-${PROJECT_NAME}-${ENVIRONMENT}"
    if [ "$DRY_RUN" = "true" ]; then
      log_info "What-if (dry-run) stage: $stage_name"
      az deployment group what-if \
        --resource-group "$rg_name" \
        --template-file "$template" \
        ${PARAMS_FILE:+--parameters "$PARAMS_FILE"} \
        --name "$deploy_name"
    else
      log_info "Deploying stage: $stage_name (resource group scope)"
      az deployment group create \
        --resource-group "$rg_name" \
        --template-file "$template" \
        ${PARAMS_FILE:+--parameters "$PARAMS_FILE"} \
        --name "$deploy_name"
    fi
  fi
}

# ---------------------------------------------------------------------------
# Stage execution -- Bicep destroy
# ---------------------------------------------------------------------------
destroy_bicep_stage() {
  local stage_name="$1"

  # Bicep does not have native destroy -- delete the resource group
  # Only the foundation stage creates the resource group, so only destroy that
  if [ "$stage_name" = "foundation" ]; then
    local rg_name="rg-${PROJECT_NAME}-${ENVIRONMENT}"
    if az group show --name "$rg_name" &>/dev/null; then
      if [ "$DRY_RUN" = "true" ]; then
        log_info "Would delete resource group: $rg_name (dry-run)"
      else
        log_info "Deleting resource group: $rg_name"
        az group delete --name "$rg_name" --yes --no-wait
        log_warn "Resource group deletion initiated (--no-wait). Check Azure portal for status."
      fi
    else
      log_warn "Resource group not found: $rg_name (skipping)"
    fi
  else
    log_info "Skipping destroy for stage: $stage_name (handled by foundation teardown)"
  fi
}

# ---------------------------------------------------------------------------
# Stage dispatcher
# ---------------------------------------------------------------------------
deploy_stage() {
  local stage_name="$1"

  if [ "$DESTROY" = "true" ]; then
    if [ "$IAC_TOOL" = "terraform" ]; then
      destroy_terraform_stage "$stage_name"
    elif [ "$IAC_TOOL" = "bicep" ]; then
      destroy_bicep_stage "$stage_name"
    fi
  else
    if [ "$IAC_TOOL" = "terraform" ]; then
      deploy_terraform_stage "$stage_name"
    elif [ "$IAC_TOOL" = "bicep" ]; then
      deploy_bicep_stage "$stage_name"
    fi
  fi
}

# ---------------------------------------------------------------------------
# Determine which stages to run
# ---------------------------------------------------------------------------
get_stages_to_run() {
  # Single stage
  if [ -n "$TARGET_STAGE" ]; then
    echo "$TARGET_STAGE"
    return
  fi

  local started=false
  if [ -z "$FROM_STAGE" ]; then
    started=true
  fi

  # Destroy runs in reverse order
  local ordered_stages=("${STAGES[@]}")
  if [ "$DESTROY" = "true" ]; then
    local reversed=()
    for (( i=${#ordered_stages[@]}-1; i>=0; i-- )); do
      reversed+=("${ordered_stages[$i]}")
    done
    ordered_stages=("${reversed[@]}")
  fi

  for stage in "${ordered_stages[@]}"; do
    if [ "$started" = false ] && [ "$stage" = "$FROM_STAGE" ]; then
      started=true
    fi
    if [ "$started" = true ]; then
      echo "$stage"
    fi
  done
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------
main() {
  log_info "Starting deployment..."
  log_info "Project: $PROJECT_NAME | Environment: $ENVIRONMENT | Location: $LOCATION"
  log_info "IaC Tool: $IAC_TOOL | Dry Run: $DRY_RUN | Destroy: $DESTROY"

  check_prerequisites
  load_variables

  local stages_to_run
  stages_to_run=$(get_stages_to_run)

  if [ -z "$stages_to_run" ]; then
    log_warn "No stages to run."
    exit 0
  fi

  for stage in $stages_to_run; do
    log_stage "$stage"

    if ! deploy_stage "$stage"; then
      FAILED_STAGE="$stage"
      log_error "Stage failed: $stage"
      exit 1
    fi

    DEPLOYED_STAGES+=("$stage")
    log_success "Stage completed: $stage"
  done
}

main "$@"
```

## Error Handling

### Set Strict Mode

Always start with `set -euo pipefail`:

- `set -e` -- Exit immediately on any command failure
- `set -u` -- Treat unset variables as errors
- `set -o pipefail` -- Pipe failure propagates (not just the last command)

### Trap for Cleanup

The `trap cleanup EXIT` pattern ensures the deployment summary is always printed, even on failure. The cleanup function:

1. Calculates total duration
2. Lists completed stages
3. Reports the failed stage (if any)
4. Prints a resume command so the user can pick up where they left off

### Stage Failure Recovery

When a stage fails:

```bash
# Resume from the failed stage
./deploy.sh --from data

# Or retry just that stage
./deploy.sh --stage data
```

The deploy stage routes failures to `qa-engineer` for diagnosis before retrying.

## Prerequisite Checks

The `check_prerequisites` function verifies:

| Check | Command | Failure Action |
|-------|---------|----------------|
| Azure CLI installed | `command -v az` | Exit with install link |
| Logged in to Azure | `az account show` | Exit with `az login` instruction |
| Correct subscription | `az account show --query id` | Display for confirmation |
| Terraform installed | `command -v terraform` | Exit with install link (Terraform only) |
| Bicep installed | `az bicep version` | Auto-install via `az bicep install` |

## Variable File Loading

Variables can be loaded from multiple sources:

```bash
# environments/dev.env -- shell variables for the deploy script
export PROJECT_NAME="myproject"
export ENVIRONMENT="dev"
export LOCATION="eastus"
export SUBSCRIPTION_ID="00000000-0000-0000-0000-000000000000"
```

For Terraform, the `terraform.tfvars` file is passed via `-var-file`. For Bicep, the `.bicepparam` file is passed via `--parameters`.

## Dry-Run Mode

Dry-run mode (`--dry-run`) provides a preview without making changes:

| IaC Tool | Dry-Run Command | Execute Command |
|----------|----------------|-----------------|
| Terraform | `terraform plan` | `terraform apply` |
| Bicep (subscription) | `az deployment sub what-if` | `az deployment sub create` |
| Bicep (resource group) | `az deployment group what-if` | `az deployment group create` |

The deploy stage sets `--dry-run` automatically when the user runs `az prototype deploy --dry-run`.

## Destroy / Teardown

Destroy mode (`--destroy`) tears down resources in reverse stage order:

- **Terraform**: Runs `terraform plan -destroy` then `terraform apply` per stage, in reverse order (apps, ai, compute, messaging, data, foundation)
- **Bicep**: Deletes the resource group (which removes all contained resources). Only the foundation stage performs the actual deletion; other stages are skipped since they are contained within the resource group.

## Color Output Reference

| Color | Usage | Constant |
|-------|-------|----------|
| Blue | Informational messages | `$BLUE` |
| Green | Success messages | `$GREEN` |
| Yellow | Warnings | `$YELLOW` |
| Red | Errors | `$RED` |
| Cyan | Stage headers | `$CYAN` |

When the output is piped or not a terminal, colors should be disabled. Add this check at the top of the script if needed:

```bash
if [ ! -t 1 ]; then
  RED=''; GREEN=''; YELLOW=''; BLUE=''; CYAN=''; NC=''
fi
```

## Integration with Deploy Stage

The deploy stage (`stages/deploy_stage.py`) interacts with `deploy.sh` through:

1. **Generation** -- The build stage generates `deploy.sh` with the correct `IAC_TOOL`, `PROJECT_NAME`, and stage list based on the architecture.
2. **Execution** -- The deploy stage runs `deploy.sh` with appropriate flags (`--dry-run`, `--stage`, `--from`).
3. **Output capture** -- stdout/stderr is captured for the deployment report and error diagnosis.
4. **Error routing** -- Failures are routed to `qa-engineer` for diagnosis, with the resume command included in the error context.

```python
# How the deploy stage invokes the script
import subprocess

cmd = ["bash", "deploy.sh"]
if dry_run:
    cmd.append("--dry-run")
if stage:
    cmd.extend(["--stage", stage])

result = subprocess.run(cmd, capture_output=True, text=True, cwd=infra_dir)
```
